# <center>7 函数

## 7.1 函数的概念

- 在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用
- 虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数
- 函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用


## 7.2 函数的使用


- 声明函数
    ~~~js
    // 声明函数
    function 函数名() {
    //函数体代码
    }
    ~~~
    - function 是声明函数的关键字,必须小写
    - 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum


- 调用函数
    ~~~js
    // 调用函数
    函数名(); // 通过调用函数名来执行函数体代码
    ~~~
    - 调用的时候千万不要忘记添加小括号
    - 注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码


- 函数的封装
  - 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口
  - 简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包）


## 7.3 函数的参数

### 7.3.1 形参和实参

- 在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时，同样也需要传递相应的参数，这些参数被称为实参

| 参数 |                          说明                          |
| :--: | :----------------------------------------------------: |
| 形参 | 形式上的参数函数定义的时候传递的参数当前并不知道是什么 |
| 实参 | 实际上的参数函数调用的时候传递的参数实参是传递给形参的 |


- 参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去


- 在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时，同样也需要传递相应的参数，这些参数被称为实参
    ~~~js
    // 带参数的函数声明
    function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
    // 函数体
    }
    // 带参数的函数调用
    函数名(实参1, 实参2, 实参3...);
    ~~~


### 7.3.2 函数参数的传递过程

~~~js
// 声明函数
function getSum(num1, num2) {
    console.log(num1 + num2);
}
// 调用函数
getSum(1, 3); // 4
getSum(6, 5); // 11
~~~
- 调用的时候实参值是传递给形参的
- 形参简单理解为：不用声明的变量
- 实参和形参的多个参数之间用逗号`,`分隔


### 7.3.3 函数形参和实参个数不匹配问题

|       参数个数       |                说明                |
| :------------------: | :--------------------------------: |
|  实参个等于形参个数  |            输出正确结果            |
| 实参个数多于形参个数 |          只取到形参的个数          |
| 实参个数小于形参个数 | 多的形参定义为undefined，结果为NaN |

~~~js
function sum(num1, num2) {
    console.log(num1 + num2);
}
sum(100, 200); // 形参和实参个数相等，输出正确结果
sum(100, 400, 500, 700); // 实参个数多于形参，只取到形参的个数
sum(200); // 实参个数少于形参，多的形参定义为undefined，结果为NaN
~~~
- 注意：在JavaScript中，形参的默认值是undefined

## 7.4 函数的返回值

- 有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。return 语句的语法格式如下：
    ~~~js
    // 声明函数
    // 声明函数
    function sum（）{
        ...
        return 666；
    }
    // 调用函数
    sum(); // 此时 sum 的值就等于666，因为 return 语句会把自身后面的值返回给调用者
    ~~~
    - 在使用 return 语句时，函数会停止执行，并返回指定的值
    - 如果函数没有 return ，返回的值是 undefined


- return 语句之后的代码不被执行
    ~~~js
    function add(num1，num2){
        //函数体
        return num1 + num2; // 注意：return 后的代码不执行
        alert('我不会被执行，因为前面有 return');
    }
    var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值
    alert(resNum); // 27
    ~~~


- return 只能返回一个值。如果用逗号隔开多个值，以最后一个为准
    ~~~js
    function add(num1，num2){
        //函数体
        return num1，num2;
    }
    var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值
    alert(resNum); // 6
    ~~~


- break ,continue ,return 的区别
  - break ：结束当前的循环体（如 for、while）
  - continue ：跳出本次循环，继续执行下次循环（如 for、while）
  - return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码


## 7.5 arguments的使用

- 当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参


- arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：
  - 具有 length 属性
  - 按索引方式储存数据
  - 不具有数组的 push , pop 等方法


- 利用函数求任意个数的最大值
    ~~~js
    function maxValue() {
        var max = arguments[0];
        for (var i = 0; i < arguments.length; i++) {
            if (max < arguments[i]) {
            max = arguments[i];
            }
        }
        return max;
    }
    console.log(maxValue(2, 4, 5, 9));
    console.log(maxValue(12, 4, 9));
    ~~~


## 7.6 函数的两种声明方式

- 自定义函数方式(命名函数)
  - 利用函数关键字 function 自定义函数方式
    ~~~js
    // 声明定义方式
    function fn() {...}
    // 调用
    fn();
    ~~~
  - 因为有名字，所以也被称为命名函数
  - 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面


- 函数表达式方式(匿名函数）
  - 利用函数表达式方式的写法如下：
    ~~~js
    // 这是函数表达式写法，匿名函数后面跟分号结束
    var fn = function(){...}；
    // 调用的方式，函数调用必须写到函数体下面
    fn();
    ~~~
  - 因为函数没有名字，所以也被称为匿名函数
  - 这个fn 里面存储的是一个函数
  - 函数表达式方式原理跟声明变量方式是一致的
  - 函数调用的代码必须写到函数体后面


## 7.7 函数案例

### 7.7.1 函数封装-翻转数组

~~~js
function reverse(arr) {
    var newArr = [];
    for (var i = arr.length - 1; i >= 0; i--) {
        newArr[newArr.length] = arr[i];
    }
    return newArr;
}
var arr1 = reverse([1, 3, 4, 6, 9]);
console.log(arr1);
~~~

### 7.7.2 函数封装-冒泡排序

~~~js
function sort(arr) {
    for (var i = 0; i < arr.length - 1; i++) {
        for (var j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                var temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    return arr;
}
~~~


### 7.7.3 判断闰年

~~~js
function isRun(year) {
    var flag = false;
    if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
        flag = true;
    }
    return flag;
}
console.log(isRun(2010));
console.log(isRun(2012));
~~~